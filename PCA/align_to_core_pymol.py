import json
import os
import numpy as np
from pymol import cmd, stored


def align_to_mean(raw_data_dir: str, *object_names, _self=None):
    """
    Aligns one or more PDB objects to the calculated mean structure from a PCA run.

    This script loads the mean coordinates and processing metadata from a PCA run,
    creates a temporary object for the mean structure, and then aligns the
    specified PDB objects to this mean structure using their common core atoms.
    This provides a visual verification that matches the computational alignment.

    Usage in PyMOL command line:
    run /path/to/this/script.py
    align_to_mean /path/to/your/pca_output/run_name/raw_data, object1, object2, ...

    :param raw_data_dir: The full path to the 'raw_data' directory generated by your PCA run.
    :param object_names: A comma-separated list of PDB object names open in PyMOL to align.
    """
    print("--- Starting Alignment to Mean Core Script ---")

    # --- 1. Load Metadata and Mean Coords ---
    metadata_path = os.path.join(raw_data_dir, "processing_metadata.json")
    mean_coords_path = os.path.join(raw_data_dir, "mean_coords.npy")
    # Go up one directory to find the main run_parameters.json
    run_params_path = os.path.join(os.path.dirname(raw_data_dir), "run_parameters.json")

    try:
        with open(metadata_path, "r") as f:
            metadata = json.load(f)

        mean_coords_flat = np.load(mean_coords_path)
        # --- FIX: Reshape the flat array into (N, 3) coordinates ---
        mean_coords = mean_coords_flat.reshape(-1, 3)

        with open(run_params_path, "r") as f:
            run_params = json.load(f)
            atom_selection = run_params.get("alignment_params", {}).get(
                "atom_selection", "ca"
            )

        residue_maps = metadata["residue_maps"]
        core_filter_indices = set(metadata["core_filter_indices"])
        print(
            f"Successfully loaded metadata. Found {len(core_filter_indices)} core MSA indices."
        )
        print(f"Loaded mean coordinates with shape {mean_coords.shape}.")
        print(f"PCA was performed on '{atom_selection}' atoms.")

    except Exception as e:
        print(f"Error: Could not load necessary data from {raw_data_dir}")
        print(f"Details: {e}")
        return

    # --- 2. Create Mean Structure Object in PyMOL ---
    mean_obj_name = "mean_core_structure"
    cmd.delete(mean_obj_name)  # Delete if it already exists

    atom_list = ["CA"] if atom_selection == "ca" else ["N", "CA", "C", "O"]
    canonical_atom_map = []
    for msa_idx in sorted(list(core_filter_indices)):
        for atom_name in atom_list:
            canonical_atom_map.append({"msa_index": msa_idx, "atom_name": atom_name})

    # Create a dummy PDB string and load it. This is a reliable way to create the object.
    pdb_string = ""
    for i, coord in enumerate(mean_coords):
        atom_info = canonical_atom_map[i]
        x, y, z = coord
        # Use a generic residue name like GLY since it's just for visualization
        pdb_string += f"ATOM  {i+1:>5} {atom_info['atom_name']:<4} GLY A{atom_info['msa_index']:>4}    {x:8.3f}{y:8.3f}{z:8.3f}  1.00  0.00           C  \n"

    cmd.read_pdbstr(pdb_string, mean_obj_name)
    print(f"Created temporary object '{mean_obj_name}' representing the mean core.")
    cmd.show("sticks", mean_obj_name)
    cmd.color("magenta", mean_obj_name)

    # --- 3. Define Helper Function to Create Selections ---
    def create_core_selection(object_name: str) -> str:
        pdb_sequence = cmd.get_fastastr(object_name).splitlines()[1].strip()
        matching_full_sequence = None
        for key in residue_maps.keys():
            if pdb_sequence in key:
                matching_full_sequence = key
                break
        if not matching_full_sequence:
            print(f"Error: Sequence for '{object_name}' could not be matched.")
            return ""
        residue_map = {
            int(k): v for k, v in residue_maps[matching_full_sequence].items()
        }
        aligned_to_orig_map = {v: k for k, v in residue_map.items()}
        core_orig_indices = {
            aligned_to_orig_map[i]
            for i in core_filter_indices
            if i in aligned_to_orig_map
        }
        if not core_orig_indices:
            return ""
        stored.resi_map = {}
        stored.seq_idx = 0
        cmd.iterate(
            f"({object_name} and name CA)",
            "stored.resi_map[stored.seq_idx] = int(resi); stored.seq_idx += 1",
        )
        core_resi_list = [
            stored.resi_map[i] for i in core_orig_indices if i in stored.resi_map
        ]
        if not core_resi_list:
            return ""
        return "resi " + "+".join(map(str, sorted(core_resi_list)))

    # --- 4. Loop Through Objects and Align Them ---
    if not object_names:
        print("No objects specified for alignment.")
        return

    # The selection for the target (mean) object is simply all its atoms
    target_core_selection = f"({mean_obj_name} and name {'+'.join(atom_list)})"

    for obj_name in object_names:
        print(f"\n--- Processing '{obj_name}' ---")

        mobile_core_selection_str = create_core_selection(obj_name)
        if not mobile_core_selection_str:
            print(f"Skipping alignment for '{obj_name}' due to selection error.")
            continue

        mobile_core_selection = f"({mobile_core_selection_str}) and name {'+'.join(atom_list)} and {obj_name}"

        print(f"Aligning '{obj_name}' to '{mean_obj_name}'...")
        try:
            # --- FIX: Use pair_fit for a direct structural alignment without sequence matching ---
            # pair_fit is the correct command for aligning selections of atoms that
            # are known to have a one-to-one correspondence.
            rmsd = cmd.pair_fit(mobile_core_selection, target_core_selection)

            # Get the atom count for the report
            atom_count = cmd.count_atoms(mobile_core_selection)

            print(
                f"Alignment successful for '{obj_name}'. RMSD: {rmsd:.4f} over {atom_count} atoms."
            )
        except Exception as e:
            print(f"An error occurred during alignment for '{obj_name}': {e}")

    print("\n--- Script Finished ---")


# Make the function available as a command in PyMOL
cmd.extend("align_to_mean", align_to_mean)

# --- Example of how to use this script ---
# 1. Save this file as "align_to_mean.py".
# 2. Open PyMOL.
# 3. Load the PDB files you want to compare, e.g.:
#    load C:/path/to/pdb1.pdb, object1
#    load C:/path/to/pdb2.pdb, object2
# 4. Run this script from the PyMOL command line:
#    run C:/path/to/align_to_mean.py
# 5. Call the new command with the path to your 'raw_data' directory and your object names:
#    align_to_mean C:/path/to/pca_output/your_run_name/raw_data, object1, object2
