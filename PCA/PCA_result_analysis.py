import os
import logging
import numpy as np
import pandas as pd
import plotly.express as px
from sklearn.cluster import HDBSCAN  # type: ignore Using the official sklearn implementation
from typing import Optional, List

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s", force=True)
logger = logging.getLogger("PDB_PCA_Analyzer")


class PCAAnalyzer:
    """
    Takes pre-calculated PCA results and performs analysis, HDBSCAN clustering,
    and visualization using the scikit-learn library.
    """

    def __init__(self, raw_data_directory):
        self.raw_data_dir = raw_data_directory
        self.graphs_dir = os.path.join(os.path.dirname(raw_data_directory), "graphs")
        os.makedirs(self.graphs_dir, exist_ok=True)

        # Load the data generated by the calculator
        self.pc_df = pd.read_csv(
            os.path.join(self.raw_data_dir, "principal_components.csv")
        )
        self.explained_variance = np.loadtxt(
            os.path.join(self.raw_data_dir, "explained_variance_ratio.csv"),
            delimiter=",",
            skiprows=1,
        )
        logger.info(f"Analyzer initialized. Loaded data for {len(self.pc_df)} PDBs.")

    def run_analysis(
        self,
        target_for_plotting: Optional[str] = None,
        pcs_to_plot: Optional[List[int]] = None,
        min_cluster_size: Optional[int] = None,
        pcs_for_clustering: Optional[int] = None,  # New parameter
    ):
        """
        Executes all analysis and output steps using HDBSCAN.

        Args:
            target_for_plotting (str, optional): The name of a specific PDB to highlight in plots.
            pcs_to_plot (list, optional): A list of 2 or 3 integers specifying which PCs to plot. Defaults to [1, 2, 3].
            min_cluster_size (int, optional): The minimum size of a group to be considered a cluster.
                                             If None, a reasonable default will be calculated.
            pcs_for_clustering (int, optional): The number of principal components to use for clustering.
                                                If None, all PCs will be used. Defaults to None.
        """
        if pcs_to_plot is None:
            pcs_to_plot = [1, 2, 3]

        # Pass the new parameter to the clustering method
        self._perform_hdbscan_clustering(
            min_cluster_size=min_cluster_size, pcs_for_clustering=pcs_for_clustering
        )
        self._save_analysis_results()
        self._generate_plots(target_for_plotting, pcs_to_plot)
        logger.info(
            f"Analysis complete. Graphs and analysis files saved in parent directory of {self.raw_data_dir}"
        )

    def _perform_hdbscan_clustering(
        self,
        min_cluster_size: Optional[int] = None,
        pcs_for_clustering: Optional[int] = None,
    ):
        """
        Performs HDBSCAN clustering on the principal components.
        """
        # New feature: Select which PCs to use for clustering
        if pcs_for_clustering is not None and pcs_for_clustering > 0:
            num_pcs = min(
                pcs_for_clustering, len(self.pc_df.columns) - 2
            )  # -2 for PDB_Name and Source_Directory
            pc_columns = [f"PC{i+1}" for i in range(num_pcs)]
            logger.info(
                f"Using the first {num_pcs} Principal Components for clustering."
            )
        else:
            pc_columns = [col for col in self.pc_df.columns if col.startswith("PC")]
            logger.info("Using all Principal Components for clustering.")

        principal_components = self.pc_df[pc_columns].values

        if min_cluster_size is None:
            min_cluster_size = 5
            logger.info(
                f"min_cluster_size not provided. Using a default value of {min_cluster_size}."
            )

        logger.info(
            f"Performing HDBSCAN clustering with min_cluster_size = {min_cluster_size}..."
        )

        # Instantiate the model from sklearn.cluster
        clusterer = HDBSCAN(min_cluster_size=min_cluster_size)

        labels = clusterer.fit_predict(principal_components)
        self.pc_df["Cluster_Label"] = labels

        final_clusters = len(set(labels)) - (1 if -1 in labels else 0)
        final_outliers = np.sum(labels == -1)
        logger.info(
            f"Clustering complete. Found {final_clusters} clusters and {final_outliers} outliers."
        )

    def _save_analysis_results(self):
        """Saves the results of the clustering analysis."""
        logger.info("Saving analysis results...")
        self.pc_df.to_csv(
            os.path.join(self.raw_data_dir, "principal_components_with_labels.csv"),
            index=False,
        )

        outlier_pdb_names = self.pc_df[self.pc_df["Cluster_Label"] == -1][
            "PDB_Name"
        ].tolist()
        pd.DataFrame(outlier_pdb_names, columns=["Outlier_PDB_Name"]).to_csv(
            os.path.join(self.raw_data_dir, "outliers.csv"), index=False
        )
        logger.info(f"Identified and saved {len(outlier_pdb_names)} outliers.")

    def _get_unique_filepath(self, filepath):
        """Checks if a file exists and appends a number if it does."""
        if not os.path.exists(filepath):
            return filepath

        directory, filename = os.path.split(filepath)
        name, ext = os.path.splitext(filename)

        parts = name.split("_")
        try:
            counter = int(parts[-1]) + 1
            base_name = "_".join(parts[:-1])
        except (ValueError, IndexError):
            counter = 1
            base_name = name

        while True:
            new_name = f"{base_name}_{counter:02d}{ext}"
            new_path = os.path.join(directory, new_name)
            if not os.path.exists(new_path):
                return new_path
            counter += 1

    def _generate_plots(self, target_for_plotting, pcs_to_plot):
        """Generates all 2D and 3D interactive plots based on specified PCs."""
        logger.info(f"Generating interactive plots for PCs: {pcs_to_plot}...")

        if len(pcs_to_plot) < 2:
            logger.error(
                "Cannot generate plots. Please provide at least two PCs in pcs_to_plot list."
            )
            return

        pc_x = f"PC{pcs_to_plot[0]}"
        pc_y = f"PC{pcs_to_plot[1]}"
        pc_z = f"PC{pcs_to_plot[2]}" if len(pcs_to_plot) >= 3 else None
        target_name = (
            os.path.basename(target_for_plotting) if target_for_plotting else None
        )

        # --- Plot 1: By HDBSCAN Cluster ---
        plot_df_cluster = self.pc_df.copy()
        plot_df_cluster["Plot_Label"] = [
            f"Cluster {l}" if l != -1 else "Outlier"
            for l in plot_df_cluster["Cluster_Label"]
        ]
        unique_labels = sorted(plot_df_cluster["Plot_Label"].unique())
        color_map = {
            label: color
            for label, color in zip(unique_labels, px.colors.qualitative.Plotly)
        }
        if "Outlier" in color_map:
            color_map["Outlier"] = "lightgrey"
        symbol_map = {}
        if target_name:
            plot_df_cluster.loc[
                plot_df_cluster["PDB_Name"] == target_name, "Plot_Label"
            ] = "Target"
            color_map["Target"] = "red"
            symbol_map["Target"] = "diamond"

        # --- Plot 2: By Source Directory ---
        plot_df_source = self.pc_df.copy()
        if target_name:
            plot_df_source["Size"] = np.where(
                plot_df_source["PDB_Name"] == target_name, 12, 5
            )
            plot_df_source["Symbol"] = np.where(
                plot_df_source["PDB_Name"] == target_name, "diamond", "circle"
            )

            source_colors = px.colors.qualitative.Plotly
            unique_sources = plot_df_source["Source_Directory"].unique()
            source_color_map = {
                source: source_colors[i % len(source_colors)]
                for i, source in enumerate(unique_sources)
            }

            target_source_dir = plot_df_source[
                plot_df_source["PDB_Name"] == target_name
            ]["Source_Directory"].iloc[0]
            source_color_map[target_source_dir] = "red"
        else:
            plot_df_source["Size"] = 5
            plot_df_source["Symbol"] = "circle"
            source_color_map = None

        # --- Generate and Save Plots ---
        plot_configs = {
            "hdbscan_cluster": {
                "df": plot_df_cluster,
                "color": "Plot_Label",
                "symbol": "Plot_Label",
                "c_map": color_map,
                "s_map": symbol_map,
                "size": None,
                "title": "PCA by HDBSCAN Cluster",
            },
            "source_directory": {
                "df": plot_df_source,
                "color": "Source_Directory",
                "symbol": "Symbol",
                "c_map": source_color_map,
                "s_map": {"diamond": "diamond", "circle": "circle"},
                "size": "Size",
                "title": "PCA by Source Directory",
            },
        }

        for name, config in plot_configs.items():
            fig_2d = px.scatter(
                config["df"],
                x=pc_x,
                y=pc_y,
                color=config["color"],
                symbol=config["symbol"],
                size=config["size"],
                color_discrete_map=config["c_map"],
                symbol_map=config["s_map"],
                hover_name="PDB_Name",
                labels={
                    pc_x: f"{pc_x} ({self.explained_variance[pcs_to_plot[0]-1]:.2%})",
                    pc_y: f"{pc_y} ({self.explained_variance[pcs_to_plot[1]-1]:.2%})",
                },
                title=config["title"],
                size_max=18,
            )
            filepath_2d = self._get_unique_filepath(
                os.path.join(self.graphs_dir, f"plot_2D_by_{name}.html")
            )
            fig_2d.write_html(filepath_2d)

            if pc_z:
                fig_3d = px.scatter_3d(
                    config["df"],
                    x=pc_x,
                    y=pc_y,
                    z=pc_z,
                    color=config["color"],
                    symbol=config["symbol"],
                    size=config["size"],
                    color_discrete_map=config["c_map"],
                    symbol_map=config["s_map"],
                    hover_name="PDB_Name",
                    labels={
                        pc_x: f"{pc_x} ({self.explained_variance[pcs_to_plot[0]-1]:.2%})",
                        pc_y: f"{pc_y} ({self.explained_variance[pcs_to_plot[1]-1]:.2%})",
                        pc_z: f"{pc_z} ({self.explained_variance[pcs_to_plot[2]-1]:.2%})",
                    },
                    title=f"{config['title']} (3D)",
                    size_max=18,
                )
                filepath_3d = self._get_unique_filepath(
                    os.path.join(self.graphs_dir, f"plot_3D_by_{name}.html")
                )
                fig_3d.write_html(filepath_3d)
